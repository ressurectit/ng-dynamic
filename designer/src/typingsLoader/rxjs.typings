// Generated by dts-bundle v0.7.3

declare module 'rxjs' {
    export { Observable } from 'rxjs/internal/Observable';
    export { ConnectableObservable } from 'rxjs/internal/observable/ConnectableObservable';
    export { GroupedObservable } from 'rxjs/internal/operators/groupBy';
    export { Operator } from 'rxjs/internal/Operator';
    export { observable } from 'rxjs/internal/symbol/observable';
    export { Subject } from 'rxjs/internal/Subject';
    export { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
    export { ReplaySubject } from 'rxjs/internal/ReplaySubject';
    export { AsyncSubject } from 'rxjs/internal/AsyncSubject';
    export { asap as asapScheduler } from 'rxjs/internal/scheduler/asap';
    export { async as asyncScheduler } from 'rxjs/internal/scheduler/async';
    export { queue as queueScheduler } from 'rxjs/internal/scheduler/queue';
    export { animationFrame as animationFrameScheduler } from 'rxjs/internal/scheduler/animationFrame';
    export { VirtualTimeScheduler, VirtualAction } from 'rxjs/internal/scheduler/VirtualTimeScheduler';
    export { Scheduler } from 'rxjs/internal/Scheduler';
    export { Subscription } from 'rxjs/internal/Subscription';
    export { Subscriber } from 'rxjs/internal/Subscriber';
    export { Notification } from 'rxjs/internal/Notification';
    export { pipe } from 'rxjs/internal/util/pipe';
    export { noop } from 'rxjs/internal/util/noop';
    export { identity } from 'rxjs/internal/util/identity';
    export { isObservable } from 'rxjs/internal/util/isObservable';
    export { ArgumentOutOfRangeError } from 'rxjs/internal/util/ArgumentOutOfRangeError';
    export { EmptyError } from 'rxjs/internal/util/EmptyError';
    export { ObjectUnsubscribedError } from 'rxjs/internal/util/ObjectUnsubscribedError';
    export { UnsubscriptionError } from 'rxjs/internal/util/UnsubscriptionError';
    export { TimeoutError } from 'rxjs/internal/util/TimeoutError';
    export { bindCallback } from 'rxjs/internal/observable/bindCallback';
    export { bindNodeCallback } from 'rxjs/internal/observable/bindNodeCallback';
    export { combineLatest } from 'rxjs/internal/observable/combineLatest';
    export { concat } from 'rxjs/internal/observable/concat';
    export { defer } from 'rxjs/internal/observable/defer';
    export { empty } from 'rxjs/internal/observable/empty';
    export { forkJoin } from 'rxjs/internal/observable/forkJoin';
    export { from } from 'rxjs/internal/observable/from';
    export { fromEvent } from 'rxjs/internal/observable/fromEvent';
    export { fromEventPattern } from 'rxjs/internal/observable/fromEventPattern';
    export { generate } from 'rxjs/internal/observable/generate';
    export { iif } from 'rxjs/internal/observable/iif';
    export { interval } from 'rxjs/internal/observable/interval';
    export { merge } from 'rxjs/internal/observable/merge';
    export { never } from 'rxjs/internal/observable/never';
    export { of } from 'rxjs/internal/observable/of';
    export { onErrorResumeNext } from 'rxjs/internal/observable/onErrorResumeNext';
    export { pairs } from 'rxjs/internal/observable/pairs';
    export { race } from 'rxjs/internal/observable/race';
    export { range } from 'rxjs/internal/observable/range';
    export { throwError } from 'rxjs/internal/observable/throwError';
    export { timer } from 'rxjs/internal/observable/timer';
    export { using } from 'rxjs/internal/observable/using';
    export { zip } from 'rxjs/internal/observable/zip';
    export { EMPTY } from 'rxjs/internal/observable/empty';
    export { NEVER } from 'rxjs/internal/observable/never';
    export * from 'rxjs/internal/types';
    export { config } from 'rxjs/internal/config';
}

declare module 'rxjs/internal/Observable' {
    import { Operator } from 'rxjs/internal/Operator';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from 'rxjs/internal/types';
    import { iif } from 'rxjs/internal/observable/iif';
    import { throwError } from 'rxjs/internal/observable/throwError';
    /**
        * A representation of any set of values over any amount of time. This is the most basic building block
        * of RxJS.
        *
        * @class Observable<T>
        */
    export class Observable<T> implements Subscribable<T> {
            /** Internal implementation detail, do not use directly. */
            _isScalar: boolean;
            /** @deprecated This is an internal implementation detail, do not use. */
            source: Observable<any>;
            /** @deprecated This is an internal implementation detail, do not use. */
            operator: Operator<any, T>;
            /**
                * @constructor
                * @param {Function} subscribe the function that is called when the Observable is
                * initially subscribed to. This function is given a Subscriber, to which new values
                * can be `next`ed, or an `error` method can be called to raise an error, or
                * `complete` can be called to notify of a successful completion.
                */
            constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic);
            /**
                * Creates a new cold Observable by calling the Observable constructor
                * @static true
                * @owner Observable
                * @method create
                * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
                * @return {Observable} a new cold observable
                * @nocollapse
                */
            static create: Function;
            /**
                * Creates a new Observable, with this Observable as the source, and the passed
                * operator defined as the new observable's operator.
                * @method lift
                * @param {Operator} operator the operator defining the operation to take on the observable
                * @return {Observable} a new observable with the Operator applied
                */
            lift<R>(operator: Operator<T, R>): Observable<R>;
            subscribe(observer?: PartialObserver<T>): Subscription;
            subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
            /** @deprecated This is an internal implementation detail, do not use. */
            _trySubscribe(sink: Subscriber<T>): TeardownLogic;
            /**
                * @method forEach
                * @param {Function} next a handler for each value emitted by the observable
                * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
                * @return {Promise} a promise that either resolves on observable completion or
                *  rejects with the handled error
                */
            forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;
            /** @internal This is an internal implementation detail, do not use. */
            _subscribe(subscriber: Subscriber<any>): TeardownLogic;
            /**
                * @nocollapse
                * @deprecated In favor of iif creation function: import { iif } from 'rxjs';
                */
            static if: typeof iif;
            /**
                * @nocollapse
                * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';
                */
            static throw: typeof throwError;
            pipe(): Observable<T>;
            pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;
            pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;
            pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;
            pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;
            pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;
            pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;
            pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;
            pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;
            pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;
            pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;
            toPromise<T>(this: Observable<T>): Promise<T>;
            toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;
            toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;
    }
}

declare module 'rxjs/internal/observable/ConnectableObservable' {
    import { Subject } from 'rxjs/internal/Subject';
    import { Observable } from 'rxjs/internal/Observable';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
      * @class ConnectableObservable<T>
      */
    export class ConnectableObservable<T> extends Observable<T> {
        source: Observable<T>;
        protected subjectFactory: () => Subject<T>;
        protected _subject: Subject<T>;
        protected _refCount: number;
        protected _connection: Subscription;
        /** @internal */
        _isComplete: boolean;
        constructor(source: Observable<T>, subjectFactory: () => Subject<T>);
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
        protected getSubject(): Subject<T>;
        connect(): Subscription;
        refCount(): Observable<T>;
    }
    export const connectableObservableDescriptor: PropertyDescriptorMap;
}

declare module 'rxjs/internal/operators/groupBy' {
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { Observable } from 'rxjs/internal/Observable';
    import { Subject } from 'rxjs/internal/Subject';
    import { OperatorFunction } from 'rxjs/internal/types';
    export function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;
    export function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;
    export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;
    export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;
    export interface RefCountSubscription {
        count: number;
        unsubscribe: () => void;
        closed: boolean;
        attemptedToUnsubscribe: boolean;
    }
    /**
      * An Observable representing values belonging to the same group represented by
      * a common key. The values emitted by a GroupedObservable come from the source
      * Observable. The common key is available as the field `key` on a
      * GroupedObservable instance.
      *
      * @class GroupedObservable<K, T>
      */
    export class GroupedObservable<K, T> extends Observable<T> {
        key: K;
        /** @deprecated Do not construct this type. Internal use only */
        constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
    }
}

declare module 'rxjs/internal/Operator' {
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { TeardownLogic } from 'rxjs/internal/types';
    export interface Operator<T, R> {
        call(subscriber: Subscriber<R>, source: any): TeardownLogic;
    }
}

declare module 'rxjs/internal/symbol/observable' {
    /** Symbol.observable addition */
    global {
        interface SymbolConstructor {
            readonly observable: symbol;
        }
    }
    /** Symbol.observable or a string "@@observable". Used for interop */
    export const observable: string | symbol;
}

declare module 'rxjs/internal/Subject' {
    import { Operator } from 'rxjs/internal/Operator';
    import { Observable } from 'rxjs/internal/Observable';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { Observer, SubscriptionLike, TeardownLogic } from 'rxjs/internal/types';
    /**
        * @class SubjectSubscriber<T>
        */
    export class SubjectSubscriber<T> extends Subscriber<T> {
            protected destination: Subject<T>;
            constructor(destination: Subject<T>);
    }
    /**
        * A Subject is a special type of Observable that allows values to be
        * multicasted to many Observables. Subjects are like EventEmitters.
        *
        * Every Subject is an Observable and an Observer. You can subscribe to a
        * Subject, and you can call next to feed values as well as error and complete.
        *
        * @class Subject<T>
        */
    export class Subject<T> extends Observable<T> implements SubscriptionLike {
            observers: Observer<T>[];
            closed: boolean;
            isStopped: boolean;
            hasError: boolean;
            thrownError: any;
            constructor();
            /**@nocollapse */
            static create: Function;
            lift<R>(operator: Operator<T, R>): Observable<R>;
            next(value?: T): void;
            error(err: any): void;
            complete(): void;
            unsubscribe(): void;
            /** @deprecated This is an internal implementation detail, do not use. */
            _trySubscribe(subscriber: Subscriber<T>): TeardownLogic;
            /** @deprecated This is an internal implementation detail, do not use. */
            _subscribe(subscriber: Subscriber<T>): Subscription;
            /**
                * Creates a new Observable with this Subject as the source. You can do this
                * to create customize Observer-side logic of the Subject and conceal it from
                * code that uses the Observable.
                * @return {Observable} Observable that the Subject casts to
                */
            asObservable(): Observable<T>;
    }
    /**
        * @class AnonymousSubject<T>
        */
    export class AnonymousSubject<T> extends Subject<T> {
            protected destination?: Observer<T>;
            constructor(destination?: Observer<T>, source?: Observable<T>);
            next(value: T): void;
            error(err: any): void;
            complete(): void;
            /** @deprecated This is an internal implementation detail, do not use. */
            _subscribe(subscriber: Subscriber<T>): Subscription;
    }
}

declare module 'rxjs/internal/BehaviorSubject' {
    import { Subject } from 'rxjs/internal/Subject';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
      * A variant of Subject that requires an initial value and emits its current
      * value whenever it is subscribed to.
      *
      * @class BehaviorSubject<T>
      */
    export class BehaviorSubject<T> extends Subject<T> {
        constructor(_value: T);
        readonly value: T;
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
        getValue(): T;
        next(value: T): void;
    }
}

declare module 'rxjs/internal/ReplaySubject' {
    import { Subject } from 'rxjs/internal/Subject';
    import { SchedulerLike } from 'rxjs/internal/types';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
      * A variant of Subject that "replays" or emits old values to new subscribers.
      * It buffers a set number of values and will emit those values immediately to
      * any new subscribers in addition to emitting new values to existing subscribers.
      *
      * @class ReplaySubject<T>
      */
    export class ReplaySubject<T> extends Subject<T> {
        constructor(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike);
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
        _getNow(): number;
    }
}

declare module 'rxjs/internal/AsyncSubject' {
    import { Subject } from 'rxjs/internal/Subject';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
      * A variant of Subject that only emits a value when it completes. It will emit
      * its latest value to all its observers on completion.
      *
      * @class AsyncSubject<T>
      */
    export class AsyncSubject<T> extends Subject<T> {
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<any>): Subscription;
        next(value: T): void;
        error(error: any): void;
        complete(): void;
    }
}

declare module 'rxjs/internal/scheduler/asap' {
    import { AsapScheduler } from 'rxjs/internal/scheduler/AsapScheduler';
    /**
      *
      * Asap Scheduler
      *
      * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
      *
      * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task
      * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
      * code to end and then it will try to execute given task as fast as possible.
      *
      * `asap` scheduler will do its best to minimize time between end of currently executing code
      * and start of scheduled task. This makes it best candidate for performing so called "deferring".
      * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
      * some (although minimal) unwanted delay.
      *
      * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
      * after currently executing code. In particular, if some task was also scheduled with `asap` before,
      * that task will execute first. That being said, if you need to schedule task asynchronously, but
      * as soon as possible, `asap` scheduler is your best bet.
      *
      * ## Example
      * Compare async and asap scheduler<
      * ```javascript
      * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
      * Rx.Scheduler.asap.schedule(() => console.log('asap'));
      *
      * // Logs:
      * // "asap"
      * // "async"
      * // ... but 'asap' goes first!
      * ```
      * @static true
      * @name asap
      * @owner Scheduler
      */
    export const asap: AsapScheduler;
}

declare module 'rxjs/internal/scheduler/async' {
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    /**
      *
      * Async Scheduler
      *
      * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
      *
      * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
      * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
      * in intervals.
      *
      * If you just want to "defer" task, that is to perform it right after currently
      * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
      * better choice will be the {@link asapScheduler} scheduler.
      *
      * ## Examples
      * Use async scheduler to delay task
      * ```javascript
      * const task = () => console.log('it works!');
      *
      * Rx.Scheduler.async.schedule(task, 2000);
      *
      * // After 2 seconds logs:
      * // "it works!"
      * ```
      *
      * Use async scheduler to repeat task in intervals
      * ```javascript
      * function task(state) {
      *   console.log(state);
      *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
      *                                   // which we reschedule with new state and delay
      * }
      *
      * Rx.Scheduler.async.schedule(task, 3000, 0);
      *
      * // Logs:
      * // 0 after 3s
      * // 1 after 4s
      * // 2 after 5s
      * // 3 after 6s
      * ```
      *
      * @static true
      * @name async
      * @owner Scheduler
      */
    export const async: AsyncScheduler;
}

declare module 'rxjs/internal/scheduler/queue' {
    import { QueueScheduler } from 'rxjs/internal/scheduler/QueueScheduler';
    /**
      *
      * Queue Scheduler
      *
      * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
      *
      * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.
      *
      * When used without delay, it schedules given task synchronously - executes it right when
      * it is scheduled. However when called recursively, that is when inside the scheduled task,
      * another task is scheduled with queue scheduler, instead of executing immediately as well,
      * that task will be put on a queue and wait for current one to finish.
      *
      * This means that when you execute task with `queue` scheduler, you are sure it will end
      * before any other task scheduled with that scheduler will start.
      *
      * ## Examples
      * Schedule recursively first, then do something
      * ```javascript
      * Rx.Scheduler.queue.schedule(() => {
      *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
      *
      *   console.log('first');
      * });
      *
      * // Logs:
      * // "first"
      * // "second"
      * ```
      *
      * Reschedule itself recursively
      * ```javascript
      * Rx.Scheduler.queue.schedule(function(state) {
      *   if (state !== 0) {
      *     console.log('before', state);
      *     this.schedule(state - 1); // `this` references currently executing Action,
      *                               // which we reschedule with new state
      *     console.log('after', state);
      *   }
      * }, 0, 3);
      *
      * // In scheduler that runs recursively, you would expect:
      * // "before", 3
      * // "before", 2
      * // "before", 1
      * // "after", 1
      * // "after", 2
      * // "after", 3
      *
      * // But with queue it logs:
      * // "before", 3
      * // "after", 3
      * // "before", 2
      * // "after", 2
      * // "before", 1
      * // "after", 1
      * ```
      *
      * @static true
      * @name queue
      * @owner Scheduler
      */
    export const queue: QueueScheduler;
}

declare module 'rxjs/internal/scheduler/animationFrame' {
    import { AnimationFrameScheduler } from 'rxjs/internal/scheduler/AnimationFrameScheduler';
    /**
      *
      * Animation Frame Scheduler
      *
      * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
      *
      * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler
      * behaviour.
      *
      * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
      * It makes sure scheduled task will happen just before next browser content repaint,
      * thus performing animations as efficiently as possible.
      *
      * ## Example
      * Schedule div height animation
      * ```javascript
      * const div = document.querySelector('.some-div');
      *
      * Rx.Scheduler.animationFrame.schedule(function(height) {
      *   div.style.height = height + "px";
      *
      *   this.schedule(height + 1);  // `this` references currently executing Action,
      *                               // which we reschedule with new state
      * }, 0, 0);
      *
      * // You will see .some-div element growing in height
      * ```
      *
      * @static true
      * @name animationFrame
      * @owner Scheduler
      */
    export const animationFrame: AnimationFrameScheduler;
}

declare module 'rxjs/internal/scheduler/VirtualTimeScheduler' {
    import { AsyncAction } from 'rxjs/internal/scheduler/AsyncAction';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    import { SchedulerAction } from 'rxjs/internal/types';
    export class VirtualTimeScheduler extends AsyncScheduler {
            maxFrames: number;
            protected static frameTimeFactor: number;
            frame: number;
            index: number;
            constructor(SchedulerAction?: typeof AsyncAction, maxFrames?: number);
            /**
                * Prompt the Scheduler to execute all of its queued actions, therefore
                * clearing its queue.
                * @return {void}
                */
            flush(): void;
    }
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @nodoc
        */
    export class VirtualAction<T> extends AsyncAction<T> {
            protected scheduler: VirtualTimeScheduler;
            protected work: (this: SchedulerAction<T>, state?: T) => void;
            protected index: number;
            protected active: boolean;
            constructor(scheduler: VirtualTimeScheduler, work: (this: SchedulerAction<T>, state?: T) => void, index?: number);
            schedule(state?: T, delay?: number): Subscription;
            protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
            protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
            protected _execute(state: T, delay: number): any;
            static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>): 1 | -1 | 0;
    }
}

declare module 'rxjs/internal/Scheduler' {
    import { Action } from 'rxjs/internal/scheduler/Action';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { SchedulerLike, SchedulerAction } from 'rxjs/internal/types';
    /**
        * An execution context and a data structure to order tasks and schedule their
        * execution. Provides a notion of (potentially virtual) time, through the
        * `now()` getter method.
        *
        * Each unit of work in a Scheduler is called an `Action`.
        *
        * ```ts
        * class Scheduler {
        *   now(): number;
        *   schedule(work, delay?, state?): Subscription;
        * }
        * ```
        *
        * @class Scheduler
        * @deprecated Scheduler is an internal implementation detail of RxJS, and
        * should not be used directly. Rather, create your own class and implement
        * {@link SchedulerLike}
        */
    export class Scheduler implements SchedulerLike {
            /**
                * Note: the extra arrow function wrapper is to make testing by overriding
                * Date.now easier.
                * @nocollapse
                */
            static now: () => number;
            constructor(SchedulerAction: typeof Action, now?: () => number);
            /**
                * A getter method that returns a number representing the current time
                * (at the time this function was called) according to the scheduler's own
                * internal clock.
                * @return {number} A number that represents the current time. May or may not
                * have a relation to wall-clock time. May or may not refer to a time unit
                * (e.g. milliseconds).
                */
            now: () => number;
            /**
                * Schedules a function, `work`, for execution. May happen at some point in
                * the future, according to the `delay` parameter, if specified. May be passed
                * some context object, `state`, which will be passed to the `work` function.
                *
                * The given arguments will be processed an stored as an Action object in a
                * queue of actions.
                *
                * @param {function(state: ?T): ?Subscription} work A function representing a
                * task, or some unit of work to be executed by the Scheduler.
                * @param {number} [delay] Time to wait before executing the work, where the
                * time unit is implicit and defined by the Scheduler itself.
                * @param {T} [state] Some contextual data that the `work` function uses when
                * called by the Scheduler.
                * @return {Subscription} A subscription in order to be able to unsubscribe
                * the scheduled work.
                */
            schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
    }
}

declare module 'rxjs/internal/Subscription' {
    import { SubscriptionLike, TeardownLogic } from 'rxjs/internal/types';
    /**
        * Represents a disposable resource, such as the execution of an Observable. A
        * Subscription has one important method, `unsubscribe`, that takes no argument
        * and just disposes the resource held by the subscription.
        *
        * Additionally, subscriptions may be grouped together through the `add()`
        * method, which will attach a child Subscription to the current Subscription.
        * When a Subscription is unsubscribed, all its children (and its grandchildren)
        * will be unsubscribed as well.
        *
        * @class Subscription
        */
    export class Subscription implements SubscriptionLike {
            /** @nocollapse */
            static EMPTY: Subscription;
            /**
                * A flag to indicate whether this Subscription has already been unsubscribed.
                * @type {boolean}
                */
            closed: boolean;
            /** @internal */
            protected _parent: Subscription;
            /** @internal */
            protected _parents: Subscription[];
            /**
                * @param {function(): void} [unsubscribe] A function describing how to
                * perform the disposal of resources when the `unsubscribe` method is called.
                */
            constructor(unsubscribe?: () => void);
            /**
                * Disposes the resources held by the subscription. May, for instance, cancel
                * an ongoing Observable execution or cancel any other type of work that
                * started when the Subscription was created.
                * @return {void}
                */
            unsubscribe(): void;
            /**
                * Adds a tear down to be called during the unsubscribe() of this
                * Subscription.
                *
                * If the tear down being added is a subscription that is already
                * unsubscribed, is the same reference `add` is being called on, or is
                * `Subscription.EMPTY`, it will not be added.
                *
                * If this subscription is already in an `closed` state, the passed
                * tear down logic will be executed immediately.
                *
                * @param {TeardownLogic} teardown The additional logic to execute on
                * teardown.
                * @return {Subscription} Returns the Subscription used or created to be
                * added to the inner subscriptions list. This Subscription can be used with
                * `remove()` to remove the passed teardown logic from the inner subscriptions
                * list.
                */
            add(teardown: TeardownLogic): Subscription;
            /**
                * Removes a Subscription from the internal list of subscriptions that will
                * unsubscribe during the unsubscribe process of this Subscription.
                * @param {Subscription} subscription The subscription to remove.
                * @return {void}
                */
            remove(subscription: Subscription): void;
    }
}

declare module 'rxjs/internal/Subscriber' {
    import { Observer, PartialObserver } from 'rxjs/internal/types';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
        * Implements the {@link Observer} interface and extends the
        * {@link Subscription} class. While the {@link Observer} is the public API for
        * consuming the values of an {@link Observable}, all Observers get converted to
        * a Subscriber, in order to provide Subscription-like capabilities such as
        * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
        * implementing operators, but it is rarely used as a public API.
        *
        * @class Subscriber<T>
        */
    export class Subscriber<T> extends Subscription implements Observer<T> {
            /**
                * A static factory for a Subscriber, given a (potentially partial) definition
                * of an Observer.
                * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
                * @param {function(e: ?any): void} [error] The `error` callback of an
                * Observer.
                * @param {function(): void} [complete] The `complete` callback of an
                * Observer.
                * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
                * Observer represented by the given arguments.
                * @nocollapse
                */
            static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;
            /** @internal */ syncErrorValue: any;
            /** @internal */ syncErrorThrown: boolean;
            /** @internal */ syncErrorThrowable: boolean;
            protected isStopped: boolean;
            protected destination: PartialObserver<any> | Subscriber<any>;
            private _parentSubscription;
            /**
                * @param {Observer|function(value: T): void} [destinationOrNext] A partially
                * defined Observer or a `next` callback function.
                * @param {function(e: ?any): void} [error] The `error` callback of an
                * Observer.
                * @param {function(): void} [complete] The `complete` callback of an
                * Observer.
                */
            constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
            /**
                * The {@link Observer} callback to receive notifications of type `next` from
                * the Observable, with a value. The Observable may call this method 0 or more
                * times.
                * @param {T} [value] The `next` value.
                * @return {void}
                */
            next(value?: T): void;
            /**
                * The {@link Observer} callback to receive notifications of type `error` from
                * the Observable, with an attached `Error`. Notifies the Observer that
                * the Observable has experienced an error condition.
                * @param {any} [err] The `error` exception.
                * @return {void}
                */
            error(err?: any): void;
            /**
                * The {@link Observer} callback to receive a valueless notification of type
                * `complete` from the Observable. Notifies the Observer that the Observable
                * has finished sending push-based notifications.
                * @return {void}
                */
            complete(): void;
            unsubscribe(): void;
            protected _next(value: T): void;
            protected _error(err: any): void;
            protected _complete(): void;
            /** @deprecated This is an internal implementation detail, do not use. */
            _unsubscribeAndRecycle(): Subscriber<T>;
    }
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @ignore
        * @extends {Ignored}
        */
    export class SafeSubscriber<T> extends Subscriber<T> {
            constructor(_parentSubscriber: Subscriber<T>, observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
            next(value?: T): void;
            error(err?: any): void;
            complete(): void;
            /** @internal This is an internal implementation detail, do not use. */
            _unsubscribe(): void;
    }
}

declare module 'rxjs/internal/Notification' {
    import { PartialObserver } from 'rxjs/internal/types';
    import { Observable } from 'rxjs/internal/Observable';
    /**
        * Represents a push-based event or value that an {@link Observable} can emit.
        * This class is particularly useful for operators that manage notifications,
        * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
        * others. Besides wrapping the actual delivered value, it also annotates it
        * with metadata of, for instance, what type of push message it is (`next`,
        * `error`, or `complete`).
        *
        * @see {@link materialize}
        * @see {@link dematerialize}
        * @see {@link observeOn}
        *
        * @class Notification<T>
        */
    export class Notification<T> {
            kind: string;
            value?: T;
            error?: any;
            hasValue: boolean;
            constructor(kind: string, value?: T, error?: any);
            /**
                * Delivers to the given `observer` the value wrapped by this Notification.
                * @param {Observer} observer
                * @return
                */
            observe(observer: PartialObserver<T>): any;
            /**
                * Given some {@link Observer} callbacks, deliver the value represented by the
                * current Notification to the correctly corresponding callback.
                * @param {function(value: T): void} next An Observer `next` callback.
                * @param {function(err: any): void} [error] An Observer `error` callback.
                * @param {function(): void} [complete] An Observer `complete` callback.
                * @return {any}
                */
            do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;
            /**
                * Takes an Observer or its individual callback functions, and calls `observe`
                * or `do` methods accordingly.
                * @param {Observer|function(value: T): void} nextOrObserver An Observer or
                * the `next` callback.
                * @param {function(err: any): void} [error] An Observer `error` callback.
                * @param {function(): void} [complete] An Observer `complete` callback.
                * @return {any}
                */
            accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;
            /**
                * Returns a simple Observable that just delivers the notification represented
                * by this Notification instance.
                * @return {any}
                */
            toObservable(): Observable<T>;
            /**
                * A shortcut to create a Notification instance of the type `next` from a
                * given value.
                * @param {T} value The `next` value.
                * @return {Notification<T>} The "next" Notification representing the
                * argument.
                * @nocollapse
                */
            static createNext<T>(value: T): Notification<T>;
            /**
                * A shortcut to create a Notification instance of the type `error` from a
                * given error.
                * @param {any} [err] The `error` error.
                * @return {Notification<T>} The "error" Notification representing the
                * argument.
                * @nocollapse
                */
            static createError<T>(err?: any): Notification<T>;
            /**
                * A shortcut to create a Notification instance of the type `complete`.
                * @return {Notification<any>} The valueless "complete" Notification.
                * @nocollapse
                */
            static createComplete(): Notification<any>;
    }
}

declare module 'rxjs/internal/util/pipe' {
    import { UnaryFunction } from 'rxjs/internal/types';
    export function pipe<T>(): UnaryFunction<T, T>;
    export function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;
    export function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;
    export function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;
    export function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;
    export function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;
    export function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;
    export function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;
    export function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;
    export function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;
    export function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;
    /** @internal */
    export function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R>;
}

declare module 'rxjs/internal/util/noop' {
    export function noop(): void;
}

declare module 'rxjs/internal/util/identity' {
    export function identity<T>(x: T): T;
}

declare module 'rxjs/internal/util/isObservable' {
    import { Observable } from 'rxjs/internal/Observable';
    /**
      * Tests to see if the object is an RxJS {@link Observable}
      * @param obj the object to test
      */
    export function isObservable<T>(obj: any): obj is Observable<T>;
}

declare module 'rxjs/internal/util/ArgumentOutOfRangeError' {
    export interface ArgumentOutOfRangeError extends Error {
    }
    export interface ArgumentOutOfRangeErrorCtor {
        new (): ArgumentOutOfRangeError;
    }
    /**
      * An error thrown when an element was queried at a certain index of an
      * Observable, but no such index or position exists in that sequence.
      *
      * @see {@link elementAt}
      * @see {@link take}
      * @see {@link takeLast}
      *
      * @class ArgumentOutOfRangeError
      */
    export const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor;
}

declare module 'rxjs/internal/util/EmptyError' {
    export interface EmptyError extends Error {
    }
    export interface EmptyErrorCtor {
        new (): EmptyError;
    }
    /**
      * An error thrown when an Observable or a sequence was queried but has no
      * elements.
      *
      * @see {@link first}
      * @see {@link last}
      * @see {@link single}
      *
      * @class EmptyError
      */
    export const EmptyError: EmptyErrorCtor;
}

declare module 'rxjs/internal/util/ObjectUnsubscribedError' {
    export interface ObjectUnsubscribedError extends Error {
    }
    export interface ObjectUnsubscribedErrorCtor {
        new (): ObjectUnsubscribedError;
    }
    /**
      * An error thrown when an action is invalid because the object has been
      * unsubscribed.
      *
      * @see {@link Subject}
      * @see {@link BehaviorSubject}
      *
      * @class ObjectUnsubscribedError
      */
    export const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor;
}

declare module 'rxjs/internal/util/UnsubscriptionError' {
    export interface UnsubscriptionError extends Error {
        readonly errors: any[];
    }
    export interface UnsubscriptionErrorCtor {
        new (errors: any[]): UnsubscriptionError;
    }
    /**
      * An error thrown when one or more errors have occurred during the
      * `unsubscribe` of a {@link Subscription}.
      */
    export const UnsubscriptionError: UnsubscriptionErrorCtor;
}

declare module 'rxjs/internal/util/TimeoutError' {
    export interface TimeoutError extends Error {
    }
    export interface TimeoutErrorCtor {
        new (): TimeoutError;
    }
    /**
      * An error thrown when duetime elapses.
      *
      * @see {@link timeout}
      *
      * @class TimeoutError
      */
    export const TimeoutError: TimeoutErrorCtor;
}

declare module 'rxjs/internal/observable/bindCallback' {
    import { SchedulerLike } from 'rxjs/internal/types';
    import { Observable } from 'rxjs/internal/Observable';
    /** @deprecated resultSelector is no longer supported, use a mapping function. */
    export function bindCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;
    export function bindCallback<R1, R2, R3, R4>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): () => Observable<any[]>;
    export function bindCallback<R1, R2, R3>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;
    export function bindCallback<R1, R2>(callbackFunc: (callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;
    export function bindCallback<R1>(callbackFunc: (callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;
    export function bindCallback(callbackFunc: (callback: () => any) => any, scheduler?: SchedulerLike): () => Observable<void>;
    export function bindCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<any[]>;
    export function bindCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;
    export function bindCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;
    export function bindCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;
    export function bindCallback<A1>(callbackFunc: (arg1: A1, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;
    export function bindCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<any[]>;
    export function bindCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;
    export function bindCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;
    export function bindCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;
    export function bindCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;
    export function bindCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<any[]>;
    export function bindCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;
    export function bindCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;
    export function bindCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;
    export function bindCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;
    export function bindCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<any[]>;
    export function bindCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;
    export function bindCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;
    export function bindCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;
    export function bindCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;
    export function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<any[]>;
    export function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;
    export function bindCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;
    export function bindCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;
    export function bindCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;
    export function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((result: R) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R>;
    export function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((...results: R[]) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R[]>;
    export function bindCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;
}

declare module 'rxjs/internal/observable/bindNodeCallback' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    /** @deprecated resultSelector is deprecated, pipe to map instead */
    export function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;
    export function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;
    export function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;
    export function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;
    export function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;
    export function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;
    export function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;
    export function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;
    export function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;
    export function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;
    export function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;
    export function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;
    export function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;
    export function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;
    export function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;
    export function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;
    export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
    export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;
    export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;
    export function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;
    export function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;
    export function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
}

declare module 'rxjs/internal/observable/combineLatest' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput, SchedulerLike } from 'rxjs/internal/types';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { OuterSubscriber } from 'rxjs/internal/OuterSubscriber';
    import { Operator } from 'rxjs/internal/Operator';
    import { InnerSubscriber } from 'rxjs/internal/InnerSubscriber';
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;
    export function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;
    export function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;
    export function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;
    export function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;
    export function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;
    export function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;
    export function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;
    export function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;
    export function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;
    export function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;
    export class CombineLatestOperator<T, R> implements Operator<T, R> {
            constructor(resultSelector?: (...values: Array<any>) => R);
            call(subscriber: Subscriber<R>, source: any): any;
    }
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @ignore
        * @extends {Ignored}
        */
    export class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {
            constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R);
            protected _next(observable: any): void;
            protected _complete(): void;
            notifyComplete(unused: Subscriber<R>): void;
            notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    }
}

declare module 'rxjs/internal/observable/concat' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput, SchedulerLike } from 'rxjs/internal/types';
    export function concat<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
    export function concat<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;
    export function concat<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
    export function concat<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
    export function concat<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
    export function concat<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
    export function concat<T>(...observables: (ObservableInput<T> | SchedulerLike)[]): Observable<T>;
    export function concat<T, R>(...observables: (ObservableInput<any> | SchedulerLike)[]): Observable<R>;
}

declare module 'rxjs/internal/observable/defer' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SubscribableOrPromise } from 'rxjs/internal/types';
    /**
      * Creates an Observable that, on subscribe, calls an Observable factory to
      * make an Observable for each new Observer.
      *
      * <span class="informal">Creates the Observable lazily, that is, only when it
      * is subscribed.
      * </span>
      *
      * ![](defer.png)
      *
      * `defer` allows you to create the Observable only when the Observer
      * subscribes, and create a fresh Observable for each Observer. It waits until
      * an Observer subscribes to it, and then it generates an Observable,
      * typically with an Observable factory function. It does this afresh for each
      * subscriber, so although each subscriber may think it is subscribing to the
      * same Observable, in fact each subscriber gets its own individual
      * Observable.
      *
      * ## Example
      * ### Subscribe to either an Observable of clicks or an Observable of interval, at random
      * ```javascript
      * const clicksOrInterval = defer(function () {
      *   return Math.random() > 0.5
      *     ? fromEvent(document, 'click')
      *     : interval(1000);
      * });
      * clicksOrInterval.subscribe(x => console.log(x));
      *
      * // Results in the following behavior:
      * // If the result of Math.random() is greater than 0.5 it will listen
      * // for clicks anywhere on the "document"; when document is clicked it
      * // will log a MouseEvent object to the console. If the result is less
      * // than 0.5 it will emit ascending numbers, one every second(1000ms).
      * ```
      *
      * @see {@link Observable}
      *
      * @param {function(): SubscribableOrPromise} observableFactory The Observable
      * factory function to invoke for each Observer that subscribes to the output
      * Observable. May also return a Promise, which will be converted on the fly
      * to an Observable.
      * @return {Observable} An Observable whose Observers' subscriptions trigger
      * an invocation of the given Observable factory function.
      * @static true
      * @name defer
      * @owner Observable
      */
    export function defer<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T>;
}

declare module 'rxjs/internal/observable/empty' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    /**
        * The same Observable instance returned by any call to {@link empty} without a
        * `scheduler`. It is preferrable to use this over `empty()`.
        */
    export const EMPTY: Observable<never>;
    /**
        * Creates an Observable that emits no items to the Observer and immediately
        * emits a complete notification.
        *
        * <span class="informal">Just emits 'complete', and nothing else.
        * </span>
        *
        * ![](empty.png)
        *
        * This static operator is useful for creating a simple Observable that only
        * emits the complete notification. It can be used for composing with other
        * Observables, such as in a {@link mergeMap}.
        *
        * ## Examples
        * ### Emit the number 7, then complete
        * ```javascript
        * const result = empty().pipe(startWith(7));
        * result.subscribe(x => console.log(x));
        * ```
        *
        * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'
        * ```javascript
        * const interval$ = interval(1000);
        * result = interval$.pipe(
        *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),
        * );
        * result.subscribe(x => console.log(x));
        *
        * // Results in the following to the console:
        * // x is equal to the count on the interval eg(0,1,2,3,...)
        * // x will occur every 1000ms
        * // if x % 2 is equal to 1 print abc
        * // if x % 2 is not equal to 1 nothing will be output
        * ```
        *
        * @see {@link Observable}
        * @see {@link never}
        * @see {@link of}
        * @see {@link throwError}
        *
        * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
        * the emission of the complete notification.
        * @return {Observable} An "empty" Observable: emits only the complete
        * notification.
        * @static true
        * @name empty
        * @owner Observable
        * @deprecated Deprecated in favor of using {@link index/EMPTY} constant.
        */
    export function empty(scheduler?: SchedulerLike): Observable<never>;
    export function emptyScheduled(scheduler: SchedulerLike): Observable<never>;
}

declare module 'rxjs/internal/observable/forkJoin' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput } from 'rxjs/internal/types';
    export function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;
    export function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;
    export function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;
    export function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;
    export function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;
    export function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;
    export function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;
    export function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;
    export function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
    export function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    export function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    export function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    export function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    /** @deprecated resultSelector is deprecated, pipe to map instead */
    export function forkJoin(...args: Array<ObservableInput<any> | Function>): Observable<any>;
    export function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;
}

declare module 'rxjs/internal/observable/from' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput, SchedulerLike } from 'rxjs/internal/types';
    export function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
    export function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;
}

declare module 'rxjs/internal/observable/fromEvent' {
    import { Observable } from 'rxjs/internal/Observable';
    export interface NodeStyleEventEmitter {
        addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;
        removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;
    }
    export type NodeEventHandler = (...args: any[]) => void;
    export interface NodeCompatibleEventEmitter {
        addListener: (eventName: string, handler: NodeEventHandler) => void | {};
        removeListener: (eventName: string, handler: NodeEventHandler) => void | {};
    }
    export interface JQueryStyleEventEmitter {
        on: (eventName: string, handler: Function) => void;
        off: (eventName: string, handler: Function) => void;
    }
    export interface HasEventTargetAddRemove<E> {
        addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;
        removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;
    }
    export type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;
    export type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;
    export interface EventListenerOptions {
        capture?: boolean;
        passive?: boolean;
        once?: boolean;
    }
    export interface AddEventListenerOptions extends EventListenerOptions {
        once?: boolean;
        passive?: boolean;
    }
    export function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function fromEvent<T>(target: FromEventTarget<T>, eventName: string, resultSelector: (...args: any[]) => T): Observable<T>;
    export function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions, resultSelector: (...args: any[]) => T): Observable<T>;
}

declare module 'rxjs/internal/observable/fromEventPattern' {
    import { Observable } from 'rxjs/internal/Observable';
    export function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void): Observable<T>;
    /** @deprecated resultSelector no longer supported, pipe to map instead */
    export function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T>;
}

declare module 'rxjs/internal/observable/generate' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    export type ConditionFunc<S> = (state: S) => boolean;
    export type IterateFunc<S> = (state: S) => S;
    export type ResultFunc<S, T> = (state: S) => T;
    export interface GenerateBaseOptions<S> {
            /**
                * Initial state.
                */
            initialState: S;
            /**
                * Condition function that accepts state and returns boolean.
                * When it returns false, the generator stops.
                * If not specified, a generator never stops.
                */
            condition?: ConditionFunc<S>;
            /**
                * Iterate function that accepts state and returns new state.
                */
            iterate: IterateFunc<S>;
            /**
                * SchedulerLike to use for generation process.
                * By default, a generator starts immediately.
                */
            scheduler?: SchedulerLike;
    }
    export interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {
            /**
                * Result selection function that accepts state and returns a value to emit.
                */
            resultSelector: ResultFunc<S, T>;
    }
    /**
        * Generates an observable sequence by running a state-driven loop
        * producing the sequence's elements, using the specified scheduler
        * to send out observer messages.
        *
        * ![](generate.png)
        *
        * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
        * const res = generate(0, x => x < 10, x => x + 1, x => x);
        *
        * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>
        * const res = generate(1, x => x < 5, x =>  * 2, x => x + 1, asap);
        *
        * @see {@link from}
        * @see {@link Observable}
        *
        * @param {S} initialState Initial state.
        * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
        * @param {function (state: S): S} iterate Iteration step function.
        * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)
        * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.
        * @returns {Observable<T>} The generated sequence.
        */
    export function generate<T, S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: SchedulerLike): Observable<T>;
    /**
        * Generates an Observable by running a state-driven loop
        * that emits an element on each iteration.
        *
        * <span class="informal">Use it instead of nexting values in a for loop.</span>
        *
        * <img src="./img/generate.png" width="100%">
        *
        * `generate` allows you to create stream of values generated with a loop very similar to
        * traditional for loop. First argument of `generate` is a beginning value. Second argument
        * is a function that accepts this value and tests if some condition still holds. If it does,
        * loop continues, if not, it stops. Third value is a function which takes previously defined
        * value and modifies it in some way on each iteration. Note how these three parameters
        * are direct equivalents of three expressions in regular for loop: first expression
        * initializes some state (for example numeric index), second tests if loop can make next
        * iteration (for example if index is lower than 10) and third states how defined value
        * will be modified on every step (index will be incremented by one).
        *
        * Return value of a `generate` operator is an Observable that on each loop iteration
        * emits a value. First, condition function is ran. If it returned true, Observable
        * emits currently stored value (initial value at the first iteration) and then updates
        * that value with iterate function. If at some point condition returned false, Observable
        * completes at that moment.
        *
        * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you
        * to immediately map value that would normally be emitted by an Observable.
        *
        * If you find three anonymous functions in `generate` call hard to read, you can provide
        * single object to the operator instead. That object has properties: `initialState`,
        * `condition`, `iterate` and `resultSelector`, which should have respective values that you
        * would normally pass to `generate`. `resultSelector` is still optional, but that form
        * of calling `generate` allows you to omit `condition` as well. If you omit it, that means
        * condition always holds, so output Observable will never complete.
        *
        * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,
        * scheduler simply comes as a last argument (no matter if there is resultSelector
        * function or not). In case of single-parameter call, you can provide it as a
        * `scheduler` property on object passed to the operator. In both cases scheduler decides when
        * next iteration of the loop will happen and therefore when next value will be emitted
        * by the Observable. For example to ensure that each value is pushed to the observer
        * on separate task in event loop, you could use `async` scheduler. Note that
        * by default (when no scheduler is passed) values are simply emitted synchronously.
        *
        *
        * @example <caption>Use with condition and iterate functions.</caption>
        * const generated = generate(0, x => x < 3, x => x + 1);
        *
        * generated.subscribe(
        *   value => console.log(value),
        *   err => {},
        *   () => console.log('Yo!')
        * );
        *
        * // Logs:
        * // 0
        * // 1
        * // 2
        * // "Yo!"
        *
        *
        * @example <caption>Use with condition, iterate and resultSelector functions.</caption>
        * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);
        *
        * generated.subscribe(
        *   value => console.log(value),
        *   err => {},
        *   () => console.log('Yo!')
        * );
        *
        * // Logs:
        * // 0
        * // 1000
        * // 2000
        * // "Yo!"
        *
        *
        * @example <caption>Use with options object.</caption>
        * const generated = generate({
        *   initialState: 0,
        *   condition(value) { return value < 3; },
        *   iterate(value) { return value + 1; },
        *   resultSelector(value) { return value * 1000; }
        * });
        *
        * generated.subscribe(
        *   value => console.log(value),
        *   err => {},
        *   () => console.log('Yo!')
        * );
        *
        * // Logs:
        * // 0
        * // 1000
        * // 2000
        * // "Yo!"
        *
        * @example <caption>Use options object without condition function.</caption>
        * const generated = generate({
        *   initialState: 0,
        *   iterate(value) { return value + 1; },
        *   resultSelector(value) { return value * 1000; }
        * });
        *
        * generated.subscribe(
        *   value => console.log(value),
        *   err => {},
        *   () => console.log('Yo!') // This will never run.
        * );
        *
        * // Logs:
        * // 0
        * // 1000
        * // 2000
        * // 3000
        * // ...and never stops.
        *
        *
        * @see {@link from}
        * @see {@link create}
        *
        * @param {S} initialState Initial state.
        * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
        * @param {function (state: S): S} iterate Iteration step function.
        * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.
        * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.
        * @return {Observable<T>} The generated sequence.
        */
    export function generate<S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, scheduler?: SchedulerLike): Observable<S>;
    /**
        * Generates an observable sequence by running a state-driven loop
        * producing the sequence's elements, using the specified scheduler
        * to send out observer messages.
        * The overload accepts options object that might contain initial state, iterate,
        * condition and scheduler.
        *
        * ![](generate.png)
        *
        * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
        * const res = generate({
        *   initialState: 0,
        *   condition: x => x < 10,
        *   iterate: x => x + 1,
        * });
        *
        * @see {@link from}
        * @see {@link Observable}
        *
        * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.
        * @returns {Observable<S>} The generated sequence.
        */
    export function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;
    /**
        * Generates an observable sequence by running a state-driven loop
        * producing the sequence's elements, using the specified scheduler
        * to send out observer messages.
        * The overload accepts options object that might contain initial state, iterate,
        * condition, result selector and scheduler.
        *
        * ![](generate.png)
        *
        * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
        * const res = generate({
        *   initialState: 0,
        *   condition: x => x < 10,
        *   iterate: x => x + 1,
        *   resultSelector: x => x,
        * });
        *
        * @see {@link from}
        * @see {@link Observable}
        *
        * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.
        * @returns {Observable<T>} The generated sequence.
        */
    export function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;
}

declare module 'rxjs/internal/observable/iif' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SubscribableOrPromise } from 'rxjs/internal/types';
    /**
      * Decides at subscription time which Observable will actually be subscribed.
      *
      * <span class="informal">`If` statement for Observables.</span>
      *
      * `iif` accepts a condition function and two Observables. When
      * an Observable returned by the operator is subscribed, condition function will be called.
      * Based on what boolean it returns at that moment, consumer will subscribe either to
      * the first Observable (if condition was true) or to the second (if condition was false). Condition
      * function may also not return anything - in that case condition will be evaluated as false and
      * second Observable will be subscribed.
      *
      * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
      * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
      * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
      * to given Observable or not.
      *
      * If you have more complex logic that requires decision between more than two Observables, {@link defer}
      * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}
      * and exists only for convenience and readability reasons.
      *
      *
      * ## Examples
      * ### Change at runtime which Observable will be subscribed
      * ```javascript
      * let subscribeToFirst;
      * const firstOrSecond = iif(
      *   () => subscribeToFirst,
      *   of('first'),
      *   of('second'),
      * );
      *
      * subscribeToFirst = true;
      * firstOrSecond.subscribe(value => console.log(value));
      *
      * // Logs:
      * // "first"
      *
      * subscribeToFirst = false;
      * firstOrSecond.subscribe(value => console.log(value));
      *
      * // Logs:
      * // "second"
      *
      * ```
      *
      * ### Control an access to an Observable
      * ```javascript
      * let accessGranted;
      * const observableIfYouHaveAccess = iif(
      *   () => accessGranted,
      *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.
      * );
      *
      * accessGranted = true;
      * observableIfYouHaveAccess.subscribe(
      *   value => console.log(value),
      *   err => {},
      *   () => console.log('The end'),
      * );
      *
      * // Logs:
      * // "It seems you have an access..."
      * // "The end"
      *
      * accessGranted = false;
      * observableIfYouHaveAccess.subscribe(
      *   value => console.log(value),
      *   err => {},
      *   () => console.log('The end'),
      * );
      *
      * // Logs:
      * // "The end"
      * ```
      *
      * @see {@link defer}
      *
      * @param {function(): boolean} condition Condition which Observable should be chosen.
      * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
      * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
      * @return {Observable} Either first or second Observable, depending on condition.
      * @static true
      * @name iif
      * @owner Observable
      */
    export function iif<T, F>(condition: () => boolean, trueResult?: SubscribableOrPromise<T>, falseResult?: SubscribableOrPromise<F>): Observable<T | F>;
}

declare module 'rxjs/internal/observable/interval' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    /**
      * Creates an Observable that emits sequential numbers every specified
      * interval of time, on a specified {@link SchedulerLike}.
      *
      * <span class="informal">Emits incremental numbers periodically in time.
      * </span>
      *
      * ![](interval.png)
      *
      * `interval` returns an Observable that emits an infinite sequence of
      * ascending integers, with a constant interval of time of your choosing
      * between those emissions. The first emission is not sent immediately, but
      * only after the first period has passed. By default, this operator uses the
      * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
      * {@link SchedulerLike} to it.
      *
      * ## Example
      * Emits ascending numbers, one every second (1000ms) up to the number 3
      * ```javascript
      * import { interval } from 'rxjs';
      * import { take } from 'rxjs/operators';
      *
      * const numbers = interval(1000);
      *
      * const takeFourNumbers = numbers.pipe(take(4));
      *
      * takeFourNumbers.subscribe(x => console.log('Next: ', x));
      *
      * // Logs:
      * // Next: 0
      * // Next: 1
      * // Next: 2
      * // Next: 3
      * ```
      *
      * @see {@link timer}
      * @see {@link delay}
      *
      * @param {number} [period=0] The interval size in milliseconds (by default)
      * or the time unit determined by the scheduler's clock.
      * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
      * the emission of values, and providing a notion of "time".
      * @return {Observable} An Observable that emits a sequential number each time
      * interval.
      * @static true
      * @name interval
      * @owner Observable
      */
    export function interval(period?: number, scheduler?: SchedulerLike): Observable<number>;
}

declare module 'rxjs/internal/observable/merge' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput, SchedulerLike } from 'rxjs/internal/types';
    export function merge<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
    export function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): Observable<T>;
    export function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;
    export function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2>;
    export function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
    export function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
    export function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
    export function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
    export function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
    export function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
    export function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
    export function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
    export function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;
    export function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;
}

declare module 'rxjs/internal/observable/never' {
    import { Observable } from 'rxjs/internal/Observable';
    /**
        * An Observable that emits no items to the Observer and never completes.
        *
        * ![](never.png)
        *
        * A simple Observable that emits neither values nor errors nor the completion
        * notification. It can be used for testing purposes or for composing with other
        * Observables. Please note that by never emitting a complete notification, this
        * Observable keeps the subscription from being disposed automatically.
        * Subscriptions need to be manually disposed.
        *
        * ##  Example
        * ### Emit the number 7, then never emit anything else (not even complete)
        * ```javascript
        * function info() {
        *   console.log('Will not be called');
        * }
        * const result = NEVER.pipe(startWith(7));
        * result.subscribe(x => console.log(x), info, info);
        *
        * ```
        *
        * @see {@link Observable}
        * @see {@link index/EMPTY}
        * @see {@link of}
        * @see {@link throwError}
        */
    export const NEVER: Observable<never>;
    /**
        * @deprecated Deprecated in favor of using {@link NEVER} constant.
        */
    export function never(): Observable<never>;
}

declare module 'rxjs/internal/observable/of' {
    import { SchedulerLike } from 'rxjs/internal/types';
    import { Observable } from 'rxjs/internal/Observable';
    export function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;
    export function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;
    export function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
    export function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
    export function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
    export function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
    export function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;
    export function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;
    export function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;
    export function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;
}

declare module 'rxjs/internal/observable/onErrorResumeNext' {
    import { Observable } from 'rxjs/internal/Observable';
    import { ObservableInput } from 'rxjs/internal/types';
    export function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;
    export function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;
    export function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;
    export function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;
    export function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;
    export function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    export function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;
}

declare module 'rxjs/internal/observable/pairs' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerAction, SchedulerLike } from 'rxjs/internal/types';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { Subscription } from 'rxjs/internal/Subscription';
    /**
      * Convert an object into an Observable of `[key, value]` pairs.
      *
      * <span class="informal">Turn entries of an object into a stream.</span>
      *
      * <img src="./img/pairs.png" width="100%">
      *
      * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each
      * emitted array has exactly two elements - the first is a key from the object
      * and the second is a value corresponding to that key. Keys are extracted from
      * an object via `Object.keys` function, which means that they will be only
      * enumerable keys that are present on an object directly - not ones inherited
      * via prototype chain.
      *
      * By default these arrays are emitted synchronously. To change that you can
      * pass a {@link SchedulerLike} as a second argument to `pairs`.
      *
      * @example <caption>Converts a javascript object to an Observable</caption>
      * ```javascript
      * const obj = {
      *   foo: 42,
      *   bar: 56,
      *   baz: 78
      * };
      *
      * pairs(obj)
      * .subscribe(
      *   value => console.log(value),
      *   err => {},
      *   () => console.log('the end!')
      * );
      *
      * // Logs:
      * // ["foo": 42],
      * // ["bar": 56],
      * // ["baz": 78],
      * // "the end!"
      * ```
      *
      * @param {Object} obj The object to inspect and turn into an
      * Observable sequence.
      * @param {Scheduler} [scheduler] An optional IScheduler to schedule
      * when resulting Observable will emit values.
      * @returns {(Observable<Array<string|T>>)} An observable sequence of
      * [key, value] pairs from the object.
      */
    export function pairs<T>(obj: Object, scheduler?: SchedulerLike): Observable<[string, T]>;
    /** @internal */
    export function dispatch<T>(this: SchedulerAction<any>, state: {
        keys: string[];
        index: number;
        subscriber: Subscriber<[string, T]>;
        subscription: Subscription;
        obj: Object;
    }): void;
}

declare module 'rxjs/internal/observable/race' {
    import { Observable } from 'rxjs/internal/Observable';
    import { Operator } from 'rxjs/internal/Operator';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { TeardownLogic } from 'rxjs/internal/types';
    import { OuterSubscriber } from 'rxjs/internal/OuterSubscriber';
    import { InnerSubscriber } from 'rxjs/internal/InnerSubscriber';
    /**
        * Returns an Observable that mirrors the first source Observable to emit an item.
        *
        * ## Example
        * ### Subscribes to the observable that was the first to start emitting.
        *
        * ```javascript
        * const obs1 = interval(1000).pipe(mapTo('fast one'));
        * const obs2 = interval(3000).pipe(mapTo('medium one'));
        * const obs3 = interval(5000).pipe(mapTo('slow one'));
        *
        * race(obs3, obs1, obs2)
        * .subscribe(
        *   winner => console.log(winner)
        * );
        *
        * // result:
        * // a series of 'fast one'
        * ```
        *
        * @param {...Observables} ...observables sources used to race for which Observable emits first.
        * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
        * @static true
        * @name race
        * @owner Observable
        */
    export function race<T>(observables: Array<Observable<T>>): Observable<T>;
    export function race<T>(observables: Array<Observable<any>>): Observable<T>;
    export function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
    export class RaceOperator<T> implements Operator<T, T> {
            call(subscriber: Subscriber<T>, source: any): TeardownLogic;
    }
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @ignore
        * @extends {Ignored}
        */
    export class RaceSubscriber<T> extends OuterSubscriber<T, T> {
            constructor(destination: Subscriber<T>);
            protected _next(observable: any): void;
            protected _complete(): void;
            notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;
    }
}

declare module 'rxjs/internal/observable/range' {
    import { SchedulerAction, SchedulerLike } from 'rxjs/internal/types';
    import { Observable } from 'rxjs/internal/Observable';
    /**
      * Creates an Observable that emits a sequence of numbers within a specified
      * range.
      *
      * <span class="informal">Emits a sequence of numbers in a range.</span>
      *
      * ![](range.png)
      *
      * `range` operator emits a range of sequential integers, in order, where you
      * select the `start` of the range and its `length`. By default, uses no
      * {@link SchedulerLike} and just delivers the notifications synchronously, but may use
      * an optional {@link SchedulerLike} to regulate those deliveries.
      *
      * ## Example
      * Emits the numbers 1 to 10</caption>
      * ```javascript
      * const numbers = range(1, 10);
      * numbers.subscribe(x => console.log(x));
      * ```
      * @see {@link timer}
      * @see {@link index/interval}
      *
      * @param {number} [start=0] The value of the first integer in the sequence.
      * @param {number} [count=0] The number of sequential integers to generate.
      * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
      * the emissions of the notifications.
      * @return {Observable} An Observable of numbers that emits a finite range of
      * sequential integers.
      * @static true
      * @name range
      * @owner Observable
      */
    export function range(start?: number, count?: number, scheduler?: SchedulerLike): Observable<number>;
    /** @internal */
    export function dispatch(this: SchedulerAction<any>, state: any): void;
}

declare module 'rxjs/internal/observable/throwError' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    /**
      * Creates an Observable that emits no items to the Observer and immediately
      * emits an error notification.
      *
      * <span class="informal">Just emits 'error', and nothing else.
      * </span>
      *
      * ![](throw.png)
      *
      * This static operator is useful for creating a simple Observable that only
      * emits the error notification. It can be used for composing with other
      * Observables, such as in a {@link mergeMap}.
      *
      * ## Examples
      * ### Emit the number 7, then emit an error
      * ```javascript
      * import { throwError, concat, of } from 'rxjs';
      *
      * const result = concat(of(7), throwError(new Error('oops!')));
      * result.subscribe(x => console.log(x), e => console.error(e));
      *
      * // Logs:
      * // 7
      * // Error: oops!
      * ```
      *
      * ---
      *
      * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13
      * ```javascript
      * import { throwError, interval, of } from 'rxjs';
      * import { mergeMap } from 'rxjs/operators';
      *
      * interval(1000).pipe(
      *   mergeMap(x => x === 2
      *     ? throwError('Twos are bad')
      *     : of('a', 'b', 'c')
      *   ),
      * ).subscribe(x => console.log(x), e => console.error(e));
      *
      * // Logs:
      * // a
      * // b
      * // c
      * // a
      * // b
      * // c
      * // Twos are bad
      * ```
      *
      * @see {@link Observable}
      * @see {@link empty}
      * @see {@link never}
      * @see {@link of}
      *
      * @param {any} error The particular Error to pass to the error notification.
      * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
      * the emission of the error notification.
      * @return {Observable} An error Observable: emits only the error notification
      * using the given error argument.
      * @static true
      * @name throwError
      * @owner Observable
      */
    export function throwError(error: any, scheduler?: SchedulerLike): Observable<never>;
}

declare module 'rxjs/internal/observable/timer' {
    import { Observable } from 'rxjs/internal/Observable';
    import { SchedulerLike } from 'rxjs/internal/types';
    /**
      * Creates an Observable that starts emitting after an `dueTime` and
      * emits ever increasing numbers after each `period` of time thereafter.
      *
      * <span class="informal">Its like {@link index/interval}, but you can specify when
      * should the emissions start.</span>
      *
      * ![](timer.png)
      *
      * `timer` returns an Observable that emits an infinite sequence of ascending
      * integers, with a constant interval of time, `period` of your choosing
      * between those emissions. The first emission happens after the specified
      * `dueTime`. The initial delay may be a `Date`. By default, this
      * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you
      * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output
      * Observable emits only one value, `0`. Otherwise, it emits an infinite
      * sequence.
      *
      * ## Examples
      * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds
      * ```javascript
      * const numbers = timer(3000, 1000);
      * numbers.subscribe(x => console.log(x));
      * ```
      *
      * ### Emits one number after five seconds
      * ```javascript
      * const numbers = timer(5000);
      * numbers.subscribe(x => console.log(x));
      * ```
      * @see {@link index/interval}
      * @see {@link delay}
      *
      * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting
      * milliseconds to wait before emitting the first value of 0`.
      * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
      * subsequent numbers.
      * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
      * the emission of values, and providing a notion of "time".
      * @return {Observable} An Observable that emits a `0` after the
      * `dueTime` and ever increasing numbers after each `period` of time
      * thereafter.
      * @static true
      * @name timer
      * @owner Observable
      */
    export function timer(dueTime?: number | Date, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number>;
}

declare module 'rxjs/internal/observable/using' {
    import { Observable } from 'rxjs/internal/Observable';
    import { Unsubscribable, ObservableInput } from 'rxjs/internal/types';
    /**
      * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
      *
      * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
      *
      * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
      * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
      * that object and should return an Observable. That Observable can use resource object during its execution.
      * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
      * resource object will be shared in any way between subscriptions.
      *
      * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
      * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
      * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
      * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
      * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
      * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
      * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
      *
      * @see {@link defer}
      *
      * @param {function(): ISubscription} resourceFactory A function which creates any resource object
      * that implements `unsubscribe` method.
      * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
      * creates an Observable, that can use injected resource object.
      * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
      * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
      */
    export function using<T>(resourceFactory: () => Unsubscribable | void, observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void): Observable<T>;
}

declare module 'rxjs/internal/observable/zip' {
    import { Observable } from 'rxjs/internal/Observable';
    import { Operator } from 'rxjs/internal/Operator';
    import { ObservableInput } from 'rxjs/internal/types';
    import { Subscriber } from 'rxjs/internal/Subscriber';
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    export function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
    export function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    export function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    export function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    export function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    export function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;
    export function zip<R>(array: ObservableInput<any>[]): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R): Observable<R>;
    /** @deprecated resultSelector is no longer supported, pipe to map instead */
    export function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R): Observable<R>;
    export function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;
    export function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;
    export function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    export class ZipOperator<T, R> implements Operator<T, R> {
            resultSelector: (...values: Array<any>) => R;
            constructor(resultSelector?: (...values: Array<any>) => R);
            call(subscriber: Subscriber<R>, source: any): any;
    }
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @ignore
        * @extends {Ignored}
        */
    export class ZipSubscriber<T, R> extends Subscriber<T> {
            constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R, values?: any);
            protected _next(value: any): void;
            protected _complete(): void;
            notifyInactive(): void;
            checkIterators(): void;
            protected _tryresultSelector(args: any[]): void;
    }
}

declare module 'rxjs/internal/types' {
    import { Observable } from 'rxjs/internal/Observable';
    import { Subscription } from 'rxjs/internal/Subscription';
    /** OPERATOR INTERFACES */
    export interface UnaryFunction<T, R> {
        (source: T): R;
    }
    export interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {
    }
    export type FactoryOrValue<T> = T | (() => T);
    export interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {
    }
    export interface Timestamp<T> {
        value: T;
        timestamp: number;
    }
    export interface TimeInterval<T> {
        value: T;
        interval: number;
    }
    /** SUBSCRIPTION INTERFACES */
    export interface Unsubscribable {
        unsubscribe(): void;
    }
    export type TeardownLogic = Unsubscribable | Function | void;
    export interface SubscriptionLike extends Unsubscribable {
        unsubscribe(): void;
        readonly closed: boolean;
    }
    export type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;
    /** OBSERVABLE INTERFACES */
    export interface Subscribable<T> {
        subscribe(observer?: PartialObserver<T>): Unsubscribable;
        subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;
    }
    export type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T> | Iterable<T>;
    /** @deprecated use {@link InteropObservable } */
    export type ObservableLike<T> = InteropObservable<T>;
    export type InteropObservable<T> = {
        [Symbol.observable]: () => Subscribable<T>;
    };
    /** OBSERVER INTERFACES */
    export interface NextObserver<T> {
        closed?: boolean;
        next: (value: T) => void;
        error?: (err: any) => void;
        complete?: () => void;
    }
    export interface ErrorObserver<T> {
        closed?: boolean;
        next?: (value: T) => void;
        error: (err: any) => void;
        complete?: () => void;
    }
    export interface CompletionObserver<T> {
        closed?: boolean;
        next?: (value: T) => void;
        error?: (err: any) => void;
        complete: () => void;
    }
    export type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
    export interface Observer<T> {
        closed?: boolean;
        next: (value: T) => void;
        error: (err: any) => void;
        complete: () => void;
    }
    /** SCHEDULER INTERFACES */
    export interface SchedulerLike {
        now(): number;
        schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
    }
    export interface SchedulerAction<T> extends Subscription {
        schedule(state?: T, delay?: number): Subscription;
    }
}

declare module 'rxjs/internal/config' {
    /**
        * The global configuration object for RxJS, used to configure things
        * like what Promise contructor should used to create Promises
        */
    export const config: {
            /**
                * The promise constructor used by default for methods such as
                * {@link toPromise} and {@link forEach}
                */
            Promise: PromiseConstructorLike;
            /**
                * If true, turns on synchronous error rethrowing, which is a deprecated behavior
                * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe
                * call in a try/catch block. It also enables producer interference, a nasty bug
                * where a multicast can be broken for all observers by a downstream consumer with
                * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME
                * FOR MIGRATION REASONS.
                */
            useDeprecatedSynchronousErrorHandling: boolean;
    };
}

declare module 'rxjs/internal/scheduler/AsapScheduler' {
    import { AsyncAction } from 'rxjs/internal/scheduler/AsyncAction';
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    export class AsapScheduler extends AsyncScheduler {
        flush(action?: AsyncAction<any>): void;
    }
}

declare module 'rxjs/internal/scheduler/AsyncScheduler' {
    import { Scheduler } from 'rxjs/internal/Scheduler';
    import { Action } from 'rxjs/internal/scheduler/Action';
    import { AsyncAction } from 'rxjs/internal/scheduler/AsyncAction';
    import { SchedulerAction } from 'rxjs/internal/types';
    import { Subscription } from 'rxjs/internal/Subscription';
    export class AsyncScheduler extends Scheduler {
            static delegate?: Scheduler;
            actions: Array<AsyncAction<any>>;
            /**
                * A flag to indicate whether the Scheduler is currently executing a batch of
                * queued actions.
                * @type {boolean}
                * @deprecated internal use only
                */
            active: boolean;
            /**
                * An internal ID used to track the latest asynchronous task such as those
                * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
                * others.
                * @type {any}
                * @deprecated internal use only
                */
            scheduled: any;
            constructor(SchedulerAction: typeof Action, now?: () => number);
            schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
            flush(action: AsyncAction<any>): void;
    }
}

declare module 'rxjs/internal/scheduler/QueueScheduler' {
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    export class QueueScheduler extends AsyncScheduler {
    }
}

declare module 'rxjs/internal/scheduler/AnimationFrameScheduler' {
    import { AsyncAction } from 'rxjs/internal/scheduler/AsyncAction';
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    export class AnimationFrameScheduler extends AsyncScheduler {
        flush(action?: AsyncAction<any>): void;
    }
}

declare module 'rxjs/internal/scheduler/AsyncAction' {
    import { Action } from 'rxjs/internal/scheduler/Action';
    import { SchedulerAction } from 'rxjs/internal/types';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { AsyncScheduler } from 'rxjs/internal/scheduler/AsyncScheduler';
    /**
        * We need this JSDoc comment for affecting ESDoc.
        * @ignore
        * @extends {Ignored}
        */
    export class AsyncAction<T> extends Action<T> {
            protected scheduler: AsyncScheduler;
            protected work: (this: SchedulerAction<T>, state?: T) => void;
            id: any;
            state: T;
            delay: number;
            protected pending: boolean;
            constructor(scheduler: AsyncScheduler, work: (this: SchedulerAction<T>, state?: T) => void);
            schedule(state?: T, delay?: number): Subscription;
            protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay?: number): any;
            protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay?: number): any;
            /**
                * Immediately executes this action and the `work` it contains.
                * @return {any}
                */
            execute(state: T, delay: number): any;
            protected _execute(state: T, delay: number): any;
            /** @deprecated This is an internal implementation detail, do not use. */
            _unsubscribe(): void;
    }
}

declare module 'rxjs/internal/scheduler/Action' {
    import { Scheduler } from 'rxjs/internal/Scheduler';
    import { Subscription } from 'rxjs/internal/Subscription';
    import { SchedulerAction } from 'rxjs/internal/types';
    /**
        * A unit of work to be executed in a `scheduler`. An action is typically
        * created from within a {@link SchedulerLike} and an RxJS user does not need to concern
        * themselves about creating and manipulating an Action.
        *
        * ```ts
        * class Action<T> extends Subscription {
        *   new (scheduler: Scheduler, work: (state?: T) => void);
        *   schedule(state?: T, delay: number = 0): Subscription;
        * }
        * ```
        *
        * @class Action<T>
        */
    export class Action<T> extends Subscription {
            constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void);
            /**
                * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed
                * some context object, `state`. May happen at some point in the future,
                * according to the `delay` parameter, if specified.
                * @param {T} [state] Some contextual data that the `work` function uses when
                * called by the Scheduler.
                * @param {number} [delay] Time to wait before executing the work, where the
                * time unit is implicit and defined by the Scheduler.
                * @return {void}
                */
            schedule(state?: T, delay?: number): Subscription;
    }
}

declare module 'rxjs/internal/OuterSubscriber' {
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { InnerSubscriber } from 'rxjs/internal/InnerSubscriber';
    /**
      * We need this JSDoc comment for affecting ESDoc.
      * @ignore
      * @extends {Ignored}
      */
    export class OuterSubscriber<T, R> extends Subscriber<T> {
        notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
        notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;
        notifyComplete(innerSub: InnerSubscriber<T, R>): void;
    }
}

declare module 'rxjs/internal/InnerSubscriber' {
    import { Subscriber } from 'rxjs/internal/Subscriber';
    import { OuterSubscriber } from 'rxjs/internal/OuterSubscriber';
    /**
      * We need this JSDoc comment for affecting ESDoc.
      * @ignore
      * @extends {Ignored}
      */
    export class InnerSubscriber<T, R> extends Subscriber<R> {
        outerValue: T;
        outerIndex: number;
        constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);
        protected _next(value: R): void;
        protected _error(error: any): void;
        protected _complete(): void;
    }
}

